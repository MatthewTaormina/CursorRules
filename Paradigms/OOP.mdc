---
description: Use when designing or refactoring object-oriented code to keep classes cohesive, loosely coupled, and testable across the codebase.
globs: ["**/*.{ts,tsx,js,java,cs,py,cpp}"]
---

# Object-Oriented Best Practices (Unified Rule)

## Core Pillars (Abstraction, Encapsulation, Inheritance, Polymorphism)
- **Abstraction**: Expose only what clients must know; hide internal detail behind stable interfaces to reduce cognitive load and change risk.  
- **Encapsulation**: Keep state private; modify via well-defined methods. Avoid leaking invariants or allowing external code to mutate internal state freely. :contentReference[oaicite:3]{index=3}
- **Inheritance**: Use only for strict *is-a* relationships; shallow hierarchies only. Beware Fragile Base Class problems from parent changes cascading to children. :contentReference[oaicite:4]{index=4}
- **Polymorphism**: Program to interfaces; ensure subtypes are substitutable without breaking callers (LSP). Prefer overriding behaviour via common contracts. :contentReference[oaicite:5]{index=5}

## SOLID (Actionable)
- **S: Single Responsibility** — one reason to change; split “god objects” into cohesive classes. :contentReference[oaicite:6]{index=6} :contentReference[oaicite:7]{index=7}
- **O: Open/Closed** — extend via new classes/strategies, don’t modify stable core. :contentReference[oaicite:8]{index=8}
- **L: Liskov Substitution** — subtypes must preserve base contracts and invariants. :contentReference[oaicite:9]{index=9}
- **I: Interface Segregation** — prefer many small, focused interfaces to large “kitchen-sink” ones. :contentReference[oaicite:10]{index=10}
- **D: Dependency Inversion** — depend on abstractions; inject dependencies rather than constructing them. :contentReference[oaicite:11]{index=11}

## Composition over Inheritance
- Prefer *has-a* composition to reduce coupling and enable swapping parts (e.g., `Car` has `IEngine`, `IChassis`, `IWheels`).  
- Composition improves flexibility, reusability, and maintainability even if it adds minor boilerplate. :contentReference[oaicite:12]{index=12} :contentReference[oaicite:13]{index=13}

## Coupling, Cohesion, and Boundaries
- Aim for **loose coupling** (talk through interfaces) and **high cohesion** (each class focused).  
- Keep constructors light; inject collaborators via interfaces. Avoid reaching across layers or friends-of-friends calls. :contentReference[oaicite:14]{index=14}

## Design by Contract (lightweight)
- State **preconditions**, **postconditions**, and **invariants** in docstrings/comments or assertions.  
- Fail fast on contract breaches; don’t silently correct invalid inputs.

## Patterns (use judiciously)
- **Strategy / State / Template Method** — vary behaviour behind an interface to remain open for extension.  
- **Factory (Method/Abstract)** — centralise creation to decouple clients from concrete classes; align with DIP/OCP.  
- **Adapter / Facade** — shield domain from third-party APIs; present stable ports.  
- Avoid over-engineering; patterns are vocabulary, not trophies. :contentReference[oaicite:15]{index=15}

## Anti-patterns (avoid)
- **God Object** — too many responsibilities; split along business capabilities. :contentReference[oaicite:16]{index=16}
- **Tight Coupling** — concrete-to-concrete references; refactor to interfaces + DI. :contentReference[oaicite:17]{index=17}
- **Deep Inheritance Chains** — flatten with composition; keep hierarchies shallow. :contentReference[oaicite:18]{index=18}

## Testing & Substitutability
- Unit test via **interfaces** with mocks/fakes; assert behaviour, not internals.  
- Verify LSP by running the same contract tests against each implementation.

## Error Handling & Robustness
- Prefer explicit domain errors/Result types to signal expected failures; throw exceptions for exceptional conditions only.  
- Keep error boundaries at module/service edges; log with context and preserve causal chains.

## Refactoring Guidance
- When a class grows: extract cohesive responsibilities into collaborators; keep public API stable.  
- When a dependency is hard-wired: introduce an interface, inject it, and add tests before changing behaviour.  
- When inheritance hurts: lift shared behaviour to a helper or policy object; inject as a strategy.

## Documentation & Naming
- Document public contracts (what, why, invariants, error modes).  
- Name classes by **capability** (e.g., `InvoiceAllocator`), not implementation detail.  
- Keep interfaces small and intention-revealing; avoid “Manager”/“Helper” catch-alls. :contentReference[oaicite:19]{index=19}

## Trade-offs & Alternatives
- OOP is powerful but not a silver bullet; blend with functional techniques where purity or data-orientation is clearer. Keep cross-paradigm seams clean. :contentReference[oaicite:20]{index=20}