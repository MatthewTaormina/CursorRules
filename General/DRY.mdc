---
description: Use when reviewing or writing code to enforce the DRY principle while avoiding premature abstraction and over-engineering.
alwaysApply: true
---

# DRY Principle (Don't Repeat Yourself)

## Core Concept
- Every piece of knowledge should have a **single, unambiguous, authoritative representation**.
- Focus on eliminating **knowledge duplication**, not just literal code duplication.
- Evaluate intent: two code blocks can look similar but represent different knowledge (not a violation).

## Benefits of DRY
- **Maintainability**: fix bugs or update logic in one place instead of many.
- **Consistency**: reduces risk of inconsistencies across the codebase.
- **Reusability**: encourages modular, reusable components.
- **Collaboration**: clearer, cleaner code that’s easier to review and onboard.

## Strategies to Apply DRY
- **Abstraction & Encapsulation**: extract repeated logic into functions, classes, or methods with clear names.
- **Modular Design & SoC**: split systems into modules with distinct responsibilities (e.g., MVC).
- **Single Source of Truth (SSOT)**: centralize constants, config, and business rules; avoid scattering values.
- **Reusable Libraries/Modules**: package and import common utilities; don’t reimplement.
- **Composition & OOP Features**: use classes, inheritance, and composition carefully to reuse behaviour.

## Pragmatic Boundaries
- **Avoid Premature Abstraction**: don’t unify code until a clear pattern has emerged.
- **Rule of Three**: allow code duplication the first two times; refactor on the third.
- **WET (Write Everything Twice)**: temporary duplication is acceptable to preserve clarity.
- **AHA (Avoid Hasty Abstractions)**: let abstractions emerge from real, repeated need.

## Acceptable Duplication
- When clarity/readability is improved (small self-contained code).
- When similar code will **diverge** in the future (keep separate).
- In **tests**, where duplication is less harmful.
- In **short-lived scripts/prototypes**, where abstraction isn’t worth the effort.
- For **performance**, where eliminating function calls matters.

## Pitfalls to Avoid
- Premature abstractions that require complex conditionals.
- Over-generalizing code that harms readability.
- Forcing unrelated concerns into the same abstraction.

## Practical Guidance
- Prefer small, well-named helpers over monolithic abstractions.
- Continuously refactor as patterns emerge, but don’t over-engineer.
- Balance DRY with **KISS (Keep It Simple, Stupid)** and **YAGNI (You Aren’t Gonna Need It)**.
- Duplication is cheaper than the wrong abstraction; optimise for clarity first.