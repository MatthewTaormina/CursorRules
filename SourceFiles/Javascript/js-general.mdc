---
description: A comprehensive guide to modern JavaScript best practices, covering variable declaration, naming conventions, coding style, and module-based architecture to promote clean, maintainable, and collaborative code.
globs:
  - "**/*.js"
  - "**/*.ts"
---
# Modern JavaScript Best Practices

This rule synthesizes industry-standard best practices to guide the generation of clean, predictable, and maintainable JavaScript code.

## 1. Foundational Principles

### 1.1. Variable Declaration: `const` and `let`
* **Principle:** Default to `const` and use `let` only for variables that require reassignment. Avoid using the legacy `var` keyword in all new code due to its problematic function-level scoping and confusing hoisting behavior.
* **Rationale:** `let` and `const` are block-scoped, which makes a variable's accessibility more predictable and prevents unintended variable leakage. The use of `const` promotes immutability by default, which helps prevent accidental reassignments and signals a developer's intent.
* **Note:** `const` prevents reassignment of the variable binding itself, but it does not make the *value* immutable. Properties of an object or elements of an array declared with `const` can still be modified.

### 1.2. Naming Conventions: Clarity Above All
* **Principle:** Use naming conventions as a form of self-documentation to convey purpose and intent.
    * **`camelCase`**: For variables, functions, and object properties.
    * **`PascalCase`**: For constructors and classes.
    * **`CONSTANT_CASE`**: For global, unchangeable constants.
* **Rationale:** Consistent naming makes code easier to read and reduces the cognitive load for developers.

## 2. Core Coding Style and Formatting

### 2.1. Semicolons
* **Principle:** Every statement must be terminated with a semicolon.
* **Rationale:** While the language supports Automatic Semicolon Insertion (ASI), relying on it can lead to unpredictable behavior and subtle, hard-to-find bugs. Explicit semicolons provide a significant gain in code predictability and debugging ease, especially for teams with mixed experience levels.

### 2.2. Quotes and Template Literals
* **Principle:** Use single quotes (`'`) for string literals. Use template literals (`` ` ``) for strings that contain variables or span multiple lines.
* **Rationale:** Template literals are a powerful feature that makes string interpolation and multiline strings significantly more readable than older methods involving string concatenation or escape characters.

## 3. Modern Language Features

### 3.1. Arrow Functions
* **Principle:** Use arrow functions for anonymous functions and callbacks.
* **Rationale:** Arrow functions do not have their own `this` binding; they inherit it from the parent lexical scope. This simplifies `this` context handling and eliminates the need for workarounds like `const self = this`.
* **Avoid:** Do not use arrow functions as object methods or constructors, as their `this` context will not behave as expected.

### 3.2. Destructuring
* **Principle:** Use destructuring assignment to extract values from objects and arrays.
* **Rationale:** Destructuring improves readability by explicitly declaring which properties or elements a block of code will use, reducing repetitive boilerplate.

### 3.3. Modules
* **Principle:** Use ES module syntax (`import`/`export`) for all new code to organize and share code.
* **Rationale:** Modules run in their own private scope, which is a significant improvement over the legacy practice of using global variables. Using named exports is preferred over default exports to improve name consistency across a project.

## 4. Robustness and Maintainability

### 4.1. Error Handling
* **Principle:** Use `try...catch` for synchronous errors and `.catch()` on promises or `async/await` with `try...catch` for asynchronous operations.
* **Avoid:** Never suppress exceptions by catching an error and doing nothing, as this leads to silent failures.
* **Best Practice:** Always log errors with enough contextual information to understand the problem.

### 4.2. Functional Principles
* **Principle:** Strive to write small, pure functions that do not mutate data outside their scope.
* **Rationale:** This approach minimizes side effects, making code more predictable and easier to test. For data transformations, use immutable array methods like `map()`, `filter()`, and `reduce()` over loops that mutate the original array.